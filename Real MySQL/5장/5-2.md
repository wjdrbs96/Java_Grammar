# `랜덤 I/O와 순차 I/O`

인덱스에 대한 개념을 알기 전에 먼저 `랜덤 I/O`, `순차 I/O`에 대해서 알아보겠습니다. 

<img width="575" alt="스크린샷 2021-06-15 오전 9 21 11" src="https://user-images.githubusercontent.com/45676906/121974741-074d0a80-cdbb-11eb-921d-c296934315a3.png">

위의 그림을 보면 `랜덤 I/O`는 시스템 콜을 3번 요청하고, `순차 I/O`는 시스템 콜을 1번 요청하는 것을 볼 수 있습니다. 즉, 디스크에 기록해야 할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직였고,
랜덤 I/O는 디스크 헤드를 3번 움직인 것입니다. 디스크에 데이터를 쓰고 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정됩니다. 

즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다고 볼 수 있습니다. 

<br>

일반적으로 `쿼리를 튜닝하는 것은 랜덤 I/O 자체`를 줄여주는 것이 목적이라고 할 수 있습니다. 여기서 `랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선`하는 것을 의미합니다. 

> 참고: 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며, 풀 테이블 스캔은 순차 I/O를 사용합니다.

<br> <br>

## `인덱스란?`

인덱스가 나오면 항상 `책에 마지막에 있는 찾아보기`를 많이 비유합니다. 찾아보기도 책에서 어떤 부분을 찾을 때 쉽게 찾을 수 있도록 만들어놓은 것입니다. 
그런데 찾아보기도 양이 많으면 찾기가 쉽지 않을 것입니다. 그래서 `정렬`된 상태를 유지합니다. 

DBMS 인덱스의 자료구조는 `SortedList`와 비슷합니다. SortedList는 저장되는 값을 항상 정렬된 상태로 유지하는 자료구조입니다. 즉, DBMS 인덱스도 SortedList와 마찬가지로 저장되는 컬럼의 값을 이용해 항상 정렬된 상태로 유지합니다. 

<br>

### `SortedList 장단점`

- 장점: 정렬 상태를 유지하기 때문에 값을 검색할 때 빠르게 가져올 수 있습니다. 

- 단점: 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느립니다. 

<br>

## `인덱스의 핵심 결론`

- DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능입니다. 

- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지의 여부에 따라 결정돼야 합니다. 

- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과가 날 수 있습니다. 

<br>

## `인덱스 역할별 구분`

- 프라이머리 키: 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스입니다. PK를 의미합니다.(프라이머리 키는 NULL 값을 허용하지 않으며 중복을 허용하지 않습니다.)

- 보조인덱스: 프라이머리 키를 제외한 나머지 인덱스는 모드 보조 인덱스로 분류합니다. 

<br>

데이터 저장 방식(알고리즘) 별로 구분하는 것은 사실 상당힐 많은 분류가 가능하겠지만 대표적으로 `B-Tree 인덱스`와 `Hash 인덱스`로 구분할 수 있습니다.
이것에 대해서는 다음 글에서 다루어 보겠습니다.

<br>

## `인덱스 테스트`

실제로 [한 영상](https://youtu.be/NkZ6r6z2pBg?t=800) 에서 인덱스를 가지고 시간을 줄인 예시를 보여주는 것이 있어서 저도 한번 해보았습니다. 시나리오는 다음과 같습니다. 

- Post 테이블에 (title, content, created_at) 컬럼을 가지고 있습니다. 

- 테이블에 110만개 정도의 데이터가 존재합니다. (중복되는 title이 약 3~5개 정도 됩니다.)

- Java, Spring Boot, MyBatis로 테스트를 해볼 예정입니다. 

<br>

이런 상태로 한번 title을 기반으로 레코드 하나 조회했을 때 얼마나 걸리는지? 를 알아보고 인덱스를 걸었을 때는 어떤 효과가 있는지 까지 한번 간단하게 정리해보겠습니다. 

<br>

```sql
SELECT * FROM post ORDER BY id DESC
```

현재 위의 쿼리로 테이블을 조회했을 때 결과는 아래와 같습니다.

![스크린샷 2021-06-15 오전 10 13 00](https://user-images.githubusercontent.com/45676906/121978044-521e5080-cdc2-11eb-85be-c2756a925c59.png)

대략 거의 110만개 정도의 데이터가 존재하는 것을 볼 수 있는데요. (title, content는 그냥 임의로 랜덤 코드 값을 생성해서 넣었습니다.) 

<br>

![스크린샷 2021-06-15 오전 10 15 51](https://user-images.githubusercontent.com/45676906/121978230-b9d49b80-cdc2-11eb-97aa-2f3ff6d0310c.png)

그래서 110만개가 존재하는 post 테이블을 위에 보이는 쿼리와 같이 `title`을 가지고 조회를 해보겠습니다. 

<br>

![스크린샷 2021-06-15 오전 10 23 04](https://user-images.githubusercontent.com/45676906/121978675-aece3b00-cdc3-11eb-934f-5feb923bd23e.png)

그리고 위의 코드처럼 특정 컬럼의 존재하는 title을 가져와서 위처럼 조회를 해보았습니다.

<br>

![스크린샷 2021-06-15 오전 10 23 52](https://user-images.githubusercontent.com/45676906/121978771-de7d4300-cdc3-11eb-91c0-52a3da10ce75.png)

110만건의 데이터에서 find 했음에도 약 0.5초 정도 시간이 걸렸습니다. (어떻게 보면 오래걸린 것이고..? 어떻게 보면 오래걸리지 않은 것이라 생각합니다.)
하나의 API에서 findByTitle 쿼리 말고 다른 쿼리들도 같이 실행된다면 점점 시간이 늘어날테니 점점 시간이 오래걸릴 거 같아 좋지는 않을 거 같습니다. 

그래서 title 컬럼에 인덱스를 한번 걸고 시간 차이가 얼마나 나는지 테스트를 해보겠습니다.

<br>

![스크린샷 2021-06-15 오전 10 34 53](https://user-images.githubusercontent.com/45676906/121979619-7b8cab80-cdc5-11eb-9cd8-2ae22a4e8215.png)

설정은 위와 같이 하였습니다. 그리고 다시 한번 실행을 시켜보겠습니다. 

<br>

![스크린샷 2021-06-15 오전 10 37 20](https://user-images.githubusercontent.com/45676906/121979736-b7277580-cdc5-11eb-978c-9024a3e4463a.png)

그리고 위와 같이 인덱스를 걸어주니까 확실히 시간이 정말 빨라진 것을 볼 수 있습니다. 이렇게 이번 글에서는 간단하게 인덱스가 무엇이고 인덱스를 걸면 속도가 어느정도 향상이 되는지에 대해서 정리해보았습니다.