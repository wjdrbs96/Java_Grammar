# `B-Tree 인덱스`

B-Tree 인덱스는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 또한 가장 먼저 도입된 알고리즘입니다. 
B는 Binary가 아니라 Balanced를 의미하는데요. B가 Binary 였다면 정~말 성능상 좋지 않았을텐데 왜 그런지 그 이유에 대해서도 차근 차근 알아보겠습니다.

<br>

## `B-Tree 구조 및 특성`

B-Tree 인덱스를 제대로 사용하려면 B-Tree의 기본적인 구조는 알고 있어야 합니다. 

![스크린샷 2021-06-15 오전 10 52 20](https://user-images.githubusercontent.com/45676906/121980925-c60f2780-cdc7-11eb-8bff-9a17dadb2886.png)

B-Tree의 구조는 위와 같습니다. 최상단에 `루트 노드` 그 하위에 자식 노드들이 존재하는데요. 중간에 존재하는 노드를 `브랜치 노드`라고 하고 마지막에 존재하는 노드를 `리프 노드`라고 합니다. 
인덱스의 리프노드는 `실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있습니다.`

<br>

<img width="483" alt="스크린샷 2021-06-15 오전 10 57 35" src="https://user-images.githubusercontent.com/45676906/121981377-80069380-cdc8-11eb-96e4-0828139ffb6a.png">

B-Tree의 리프 노드와 테이블 데이터 레코드는 위의 사진과 같은 관계를 가지고 있습니다. (InnoDB 테이블에서는 프라이머리 키에 의해 클러스터링되기 때문에 프라이머리 키 값 자체가 주소 역할을 합니다.)

<br>

## `인덱스 키 검색`

`INSERT`, `UPDATE`, `DELETE` 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 `빠른 검색`을 위해서 입니다. 
인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교하 작업을 수행합니다. (`트리 탐색`)

이러한 트리 탐색은 UPDATE, INSERT를 하기 위해 검색할 때도 사용됩니다. `B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우`에 사용할 수 있습니다. 

즉, 검색할 때 `Like %{keyword}%`로 쿼리를 구현하면 인덱스를 타지 않는 다는 것! (다른 검색 엔진(ex: ElasticSearch)을 쓰거나 그러지 않는다면 어쩔 수 없이 이렇게 검색 API를 구현하긴 해야 겠지만..)

<br>

## `B-Tree 인덱스 사용에 영향을 미치는 요소`

B-Tree 인덱스는 인덱스를 구성하는 `컬럼의 크기`, `레코드의 건수`, `유니크한 인덱스 키 값의 개수` 등에 의해 검색이나 변경 작업의 성능이 영향을 받습니다. 

<br>

### `인덱스 키 값의 크기`

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 `페이지` 라고 합니다.(디스크에 모든 읽기 ㅁ치 쓰기 작업의 최소 작업 단위)
B-Tree 그림에서 루트와 브랜치, 그리고 리프 노드를 구분한 기준이 페이지 단위입니다.

<br>

만약 B-Tree가 Binary-Tree 였다면 어떻게 될까요? 하나의 노드당 자식을 최대 2개만 가질 수 있어.. 데이터가 많아진다면 뎁스가 어마어마하게 깊어지게 될 것입니다. 
즉, 검색도 비효율적이게 될 것입니다. 

그래서 B는 Binary가 아니라 Balanced 인데요. 그러면 B-Tree는 자식 노드의 개수를 몇 개까지 가질 수 있을까요? 이것은 `인덱스 페이지 크기와 키 값의 크기에 따라 결정`됩니다. 
InnoDB의 모든 페이지 크기는 16KB로 고정되어 있습니다. 만약 인덱스 키가 16바이트라면 하나의 페이지에 대략 585개의 키를 저장할 수 있습니다. 

그러면 인덱스의 키 크기가 32바이트로 늘어났다면 어떻게 될까요? 한 페이지에 인덱스 키를 372개 저장할 수 있습니다. 만약 어떤 SELECT 쿼리로 레코드 500개를 읽어야 한다면 전자는 한번에 해결할 수 있지만, 후자는 최소한 2번 이상 디스크로부터 읽어야 합니다. 
결국 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미합니다. 

<br>

## `B-Tree 깊이`

Depth와 인덱스 키 값의 크기는 연관이 있습니다. 만약 depth=3, 키 값의 크기가 16KB 라면, 대략 2억개 정도 담을 수 있다고 하는데요. 
그런데 키 값의 크기가 32KB 라면 5천만개로 줄어듭니다. 즉, `B-Tree 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제`입니다.

<br>

### `결론`

- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 작아지기 때문에 같은 레코드 건수라 하더라도 B-Tree(Depth)가 깊어져서 디크스 일기가 더 많이 필요하게 된다는 것을 의미합니다.

- 즉, 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋습니다. 

<br>

## `선택도(Cardinality)`

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미합니다. 예를들어 주민번호 같은 경우는 모든 사람이 갖는 고유의 값이기 때문에 Cardinality가 높다고 말합니다. 반면에 `성별`에 대한 정보는 2가지 뿐이기 때문에 Cardinality가 상대적으로 낮습니다.

<br>

## `B-Tree 인덱스를 통한 데이터 읽기`

어떤 경우에 인덱스를 사용하도록 유도할지, 또는 사용하지 못하게 할지 판단하려면 MySQL이 어떻게 인덱스를 이용해서 실제 레코드를 읽어 내는지 알아야합니다.(이것이 글을 쓰는 현재의 저에게는 너무나 쉽지 않지만..)
MySQL이 인덱스를 이용하는 대표적인 방법 3가지를 살펴보겠습니다.

<br>

### `인덱스 레인지 스캔`

`인덱스 레인지 스캔`은 인덱스의 접근 방법 가운데 갖아 대표적인 접근 방식입니다.

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'GAD';
```

위의 쿼리가 실행될 때 어떠한 과정으로 실행이 될까요?

<br>

![스크린샷 2021-06-16 오전 9 32 22](https://user-images.githubusercontent.com/45676906/122140248-c241da80-ce85-11eb-848f-47328c0af7d5.png)

인덱스 레인지 스캔은 `검색해야 할 인덱스의 범위가 결정됐을 때 사용`하는 방식입니다.
즉, 원하는 결과를 찾으면 결과를 사용자에게 반환하고 쿼리를 끝냅니다.

<br>

![스크린샷 2021-06-16 오전 10 09 21](https://user-images.githubusercontent.com/45676906/122142685-ec49cb80-ce8a-11eb-8db3-20ddd493a4e1.png)

B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 특정 검색 시작 값을 가지고 있는 리프 노드를 검색하고, 그 지점부터 필요한 방향(오름차순 or 내림차순)으로 인덱스를 읽어 나가는 과정을 볼 수 있습니다.
`가장 중요한 것은 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다는 것`입니다.

또 하나 그림 5-10에서 중요한 것은 인덱스의 리포 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요한데요. 이 때 레코드 한 건 한 건 `랜덤 I/O`가 실행됩니다.
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류되는 것입니다.

<br>

## `인덱스 풀 스캔`

인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 `인덱스 풀 스캔`이라고 합니다.
대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됩니다. 예를들어, 인덱스는 A, B, C 컬럼 순으로 만들어져 있지만 쿼리의 조건절은 B 컬럼이나 C 컬럼으로 검색하는 경우에 해당됩니다.

쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용됩니다. 인덱스뿐만이 아니라 데이터 레코드까지 읽어야 한다면 절대 이 방식으로 처리되지 않습니다. 

![스크린샷 2021-06-16 오전 10 28 40](https://user-images.githubusercontent.com/45676906/122144054-a17d8300-ce8d-11eb-8c9c-1d4b4f55edc1.png)

인덱스의 자체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은 테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리를 처리할 수 있습니다.

<br> <br>

# `Reference`

- [Real MySQL]()


