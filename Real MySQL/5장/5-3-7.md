# `B-Tree 인덱스의 가용성과 효율성`

쿼리의 WHERE 조건이나 `GROUP BY` 또는 `ORDER BY` 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 합니다. 
그래야만 쿼리의 조건을 최적화하거나, 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있습니다. 

<br> <br>

## `비교 조건의 종류와 효율성`

다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 `동등 조건("=")`인지 아니면 `크다(">")` 또는 `작다("<")`와 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라집니다. 

```sql
SELECT * FROM dept_emp
WHERE dept_no = 'd002' AND emp_no >= 10114;
```

이 쿼리가 dept_emp 테이블에 아래의 그림과 같이 각각 컬럼의 순서만 다른 2가지 케이스로 인덱스를 생성했다고 가정해보겠습니다.

<br>

<img width="714" alt="스크린샷 2021-07-27 오후 4 46 37" src="https://user-images.githubusercontent.com/45676906/127116359-b967af7d-bbfe-46c0-a29f-d2ee5d246da6.png">

- 케이스 A: dept_no + emp_no

- 케이스 B: emp_no + dept_no

<br>

케이스 A는 `dept_no = 'd002' AND emp_no > 10444`인 레코드를 찾고, 그 이후에는 `dept_no가 'd002'`가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 됩니다. 
이 경우에는 읽은 레코드가 모두 사용자가 원하는 결과임을 알 수 있습니다. 즉, 5건의 레코드를 찾는 데 꼭 필요한 5번의 비교 작업만 수행한 것이므로 상당히 효율적으로 인덱스를 이용한 것입니다. 

하지만 케이스 B는 우선 emp_no > 10444 AND dept_no = 'd002'인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no = 'd002'인지 비교하는 과정을 거쳐야 합니다. 
<br>
