## `Transactional readOnly=true 동작원리`

`Spring`을 사용하다 보면 `@Transactional`을 자주 사용하게 되는데요. `@Transactional` 속성 중에 `readlOnly=true` 라는 것이 있습니다. 이번 글에서는 `JPA를 사용하면서 readOnly=true`를 사용하게 되면 어떤 일이 일어나는지에 대해서 알아보겠습니다. 

<br>

### `읽기 전용 쿼리의 성능 최적화`

엔티티가 영속성 컨텍스트에 관리되면 1차 캐시부터 변경 감지까지 얻을 수 있는 해택이 많습니다. 하지만 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있습니다. 

그래서 단순 읽기 전용일 때 `readOnly=true`를 사용하면 내부 스냅샷 인스턴스를 보관하지 않기 때문에 메모리 사용량을 최적화할 수 있습니다. 단, 스냅샷이 없으므로 엔티티를 수정해도 `쓰기 지연` 기능을 사용할 수 없습니다. 

<br> 

### `읽기 전용 트랜잭션 사용`

`@Transactional(readOnly=true)`를 사용하게 되면 `스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 MANUAL`로 설정합니다. 이렇게 하면 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않습니다. 따라서 `트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않습니다.`

영속성 컨텍스트를 플러시하지 않으니 엔티티의 등록, 수정, 삭제는 당연히 동작하지 않습니다. 하지만 플러시할 때 일어나는 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상됩니다. 물론 트랜잭션을 시작했으므로 트랜잭션 시작, 로직수행, 트랜잭션 커밋의 과정은 이루어집니다. 단지 영속성 컨텍스트를 플러시하지 않을 뿐입니다. 

<br>

### `플러시(flush)란?`

1. em.flush() 직접 호출
2. 트랜잭션 커밋 시 플러시가 자동 호출됩니다.
3. JPQL 쿼리 실행 시 플러시가 자동 호출됩니다.

플러시를 호출하는 방법은 위와 같이 3가지 입니다. 플러시(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영합니다. 플러시를 실행하면 구체적으로 다음과 같은 일이 일어납니다.

변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송합니다.(등록, 수정, 삭제 쿼리)

<br>

### `참고하기`

플러시 설정에 `MANUAL` 모드를 사용하면 강제로 플러시를 호출하지 않으면 절대 플러시가 발생하지 않습니다. 