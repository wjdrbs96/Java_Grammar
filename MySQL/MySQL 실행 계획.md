## `MySQL 실행 계획`

MySQL 서버의 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인할 수 있습니다.

### `쿼리의 실행 계획 확인`

```sql
EXPLAIN SELECT * FROM bbang_map.Bakery WHERE id > 100 ORDER BY id desc;
```

<br>

### `쿼리의 실행 시간 확인`

MySQL 8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가되었습니다.

<br>

## `실행 계획 분석`

```
EXPLAIN SELECT * FROM bbang_map.Bakery WHERE id > 100 ORDER BY id desc;
```

<img width="814" alt="스크린샷 2024-03-28 오후 12 03 26" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/36d2d464-6766-47f7-b100-4a8eb084a1db">

저의 사이드 프로젝트 DB에서 임의의 쿼리로 EXPLAIN 확인해보면 위와 같이 나오는데요. 하나씩 어떤 의미를 가지고 있는지 확인 해보겠습니다.

<br>

## `id 컬럼`

쿼리에서 서브 쿼리를 사용할 수도 있고 여러 개의 SELECT가 존재할 수 있기 때문에 id 컬럼은 SELECT 쿼리 별로 부여하는 식별자 값입니다.

<br>

## `select type 컬럼`

각 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼입니다.

<br>

### `SIMPLE`

- UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 SELECT TYPE은 SIMPLE로 표시됩니다.

<br>

### `PRIMARY`

- UNION 이나 서브쿼리를 가지는 SELECT 

<br>

### `DERIVED`

`DERIVED`는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미합니다.

<br>

## `Type 컬럼`

### `const`

테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 방식을 const 라고 합니다.

<br>

### `eq_ref`

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다고 합니다. 

<br>

### `ref`

인덱스의 종류와 관계없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방식이 사용됩니다.

<br>

### `range`

range는 인덱스 레인지 스캔 형태의 접근 방법입니다.

<br>

### `index`

인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미합니다.

<br>

### `ALL`

테이블 풀 스캔하는 것을 의미합니다.

<br>

## `possible_keys 컬럼`

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 방법을 고려하고 그 중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행합니다.

possible_keys 컬럼에 있는 내용은 옵티마이저가 초지ㅓㄱ의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스 목록일 뿐입니다.

<br>

## `key 컬럼`

possible_keys 컬럼의 인덱스가 사용 후보였던 반면, key 컬럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미합니다.

- key가 PRIMARY 라면 프라이머리 키를 사용한다는 의미

<br>

## `key_len 컬럼`

쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개 컬럼까지 사용했는지를 의미합니다. 즉, 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값입니다.

<br>

## `rows 컬럼`

실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여줍니다. 이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상 값이라서 정확하지는 않습니다.

<br>

## `filtered 컬럼`

옵티마이저는 각 테이블에서 일치하는 레코드 개수를 가능하면 정확히 파악해야 좀 더 효율적인 실행 계획을 판단할 수 있습니다.

filter 컬럼의 값은 필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미합니다.

만약 filter 컬럼의 값이 50% 라면 옵티마이저는 100건 중에서 50건은 버려지고 최종 남은 50건이 반활될 것으로 예측했다는 것을 의미합니다.

<br>

## `Extra`

### `Using filesort`

order by를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는 MySQL 서버가 레코드를 다시 한번 정렬해야 합니다.

order by 처리가 인덱스를 사용하지 못할 때만 `Using filesort`가 표시 됩니다.

<br>

### `Using Index (커버링 인덱스)`

데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 Extra 컬럼에 `Using Index`가 표시됩니다.

<br>

### `Using Index condition`

MySQL 옵티마이저가 `인덱스 컨디션 푸시 다운 최적화`를 사용할 때 나타나는 값입니다.

<br>

### `Using Where`

<img width="992" alt="스크린샷 2024-04-08 오전 10 28 19" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/76b72e11-db70-4aa3-9fd7-126992c79988">

각 스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할을 하며, MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행합니다.

MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에서 `Using Where` 값이 나타납니다. 