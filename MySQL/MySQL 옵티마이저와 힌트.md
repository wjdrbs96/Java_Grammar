# `MySQL 옵티마이저와 힌트`

MySQL에서 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보를 참조하여, 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요합니다.

MySQL 서버를 포함한 대부분의 DBMS에서는 옵티마이저가 이러한 기능을 담당합니다.

<br>

## `쿼리 실행 구조` ⭐⭐⭐⭐

<img width="580" alt="스크린샷 2024-04-10 오전 12 51 30" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/bd4a6fce-87d2-4e4d-93c5-6fed1c1749b8">

- `쿼리 파서`
    - 쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미한다.
    - 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메세지를 전달하게 된다.
- `전처리기`
    - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
    - 각 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체 접근 권한 등을 확인한 과정을 수행한다.
- `옵티마이저` ⭐⭐⭐
    - 사용자의 요청으로 들어온 쿼리 문장을 가장 빠르게 처리할 수 있는 방법을 결정하는 역할을 담당하며, DBMS의 두뇌에 해당합니다.
- `실행 엔진`
    - 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.
        - `옵티마이저: 회사 경영진` ⭐⭐
        - 실행 엔진: 중간 관리자
        - 핸들러: 각 업무의 실무자
- 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정한 상황에 대한 예시
    1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
    5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

<br>

## `옵티마이저의 종류`

옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당합니다.

- `규칙 기반 최적화`: 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.
- `비용 기반 최적화`: 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.

현재는 MySQL을 포함한 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있습니다. 

<br>

## `기본 데이터 처리`

MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있는데, 내부적으로 어떤 과정을 거쳐서 데이터를 처리하는지 알아보겠습니다.

<br>

### `풀 테이블 스캔과 풀 인덱스 스캔`

- `풀 테이블 스캔`: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미

MySQL 옵티마이저는 아래와 같은 조건에서 주로 `풀 테이블 스캔`을 선택합니다.

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요합니다.

`그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블로이나 페이지를 읽어오는 기능을 내장하고 있습니다.`

<img width="749" alt="스크린샷 2024-06-23 오후 7 11 00" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/0aaa7cb7-d26a-422f-a4ed-2c670975ec71">

MySQL 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어오는 것으로 생각하는데, 이것은 `MyISAM 스토리지 엔진에는 맞는 이야기지만 InnoDB 에서는 틀린 말입니다.` ⭐⭐

<br>

### `InnoDB Read ahead` ⭐⭐⭐

- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 `백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업`이 자동으로 시작된다.
- 리드 어헤드(Read ahead)란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미함 
- 테이블 풀 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
- 리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.

```sql
SELECT COUNT(*) FROM employees;
```

- 전체 개수를 조회하는 쿼리이기 때문에 풀 테이블 스캔을 할 것처럼 보이지만, `실제 실행 계획은 풀 테이블 스캔보다는 풀 인덱스 스캔을 하게 될 가능성이 높다.` (단순히 레코드의 건수만 필요로 하는 쿼리라면 용량이 적은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문)
- 일반적으로 인덱스는 테이블의 2 ~ 3개 컬럼만으로 구성되기 때문에 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능하다.

```sql
SELECT * FROM employees;
```

하지만 위와 같이 레코드에만 있는 컬럼이 필요한 쿼리의 경우에는 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 합니다.

<br>

## `ORDER BY 처리(Using filesort)`

| --          | 장점                                                                                 | 단점                                                                                     |
|-------------|------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
| 인덱스 이용      | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 이 순서대로 읽기만 하면 되어서 매우 빠르다.        | INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 디스크 공간 및 버퍼 풀 메모리가 필요하다. |
| Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이다. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                                  |

- 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다. ⭐⭐
- WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. ⭐⭐

<br>

### `소트 버퍼`

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 `소트 버퍼(Sort Buffer)` 라고 합니다.

소트 버퍼의 공간은 [sort_buffer_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size) 라는 시스템 변수로 설정할 수 있고, 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납됩니다.

```sql
show variables where Variable_Name like '%sort_buffer%';
```

위의 명령어로 sort_buffer 사이즈를 획인할 수 있습니다.

<img width="932" alt="스크린샷 2024-04-11 오후 10 39 37" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/93cbe988-56bb-41f6-9e8e-0e7293e72c4e">

1. 메모리의 sort buffer에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록합니다.
2. 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장합니다.
3. 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 하는데, 이 작업을 `멀티 머지(Multi-merge)` 라고 합니다.

이러한 작업들이 모두 디스크의 쓰기와 읽기를 유발하기 때문에, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아져서 좋지 않습니다.

추가로 `정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미해서, 소트 버퍼의 크기를 10MB 이상으로 설정하면 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 운영체제는 메모리 부족 현상을 겪을 수도 있다고 한다.` (Real MySQL - 1 P290 참고)

<br>

### `정렬 알고리즘`

#### `싱글 패스(Single-Pass) 정렬 방식`

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식입니다.
  
```sql
mysql> SELECT emp_no, first_name, last_name
       FROM employees
       ORDER BY first_name;
```

<img width="895" alt="스크린샷 2024-08-04 오후 8 38 35" src="https://github.com/user-attachments/assets/324b613f-453f-4ef6-893d-2dd992bdee74">

정렬에 필요하지 않은 last_name 컬럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행합니다. 그리고 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨주는 과정을 볼 수 있습니다.

<br>

#### `투 패스(Two-Pass) 정렬 방식`

정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 컬럼을 가져오는 정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식입니다. (하지만 MySQL 8.0에서도 여전히 특정 조건에서는 투 패스(Two-Pass) 정렬 방식을 사용한다.)

<img width="902" alt="스크린샷 2024-08-04 오후 8 44 15" src="https://github.com/user-attachments/assets/1081a2c6-3555-437a-85c9-f9a5a337b330">

디스크에서 정렬에 필요한 first_name 컬럼과 프라이머리 키인 emp_no만 읽어서 정렬을 수행했음을 알 수 있습니다.

정렬이 완료되면 그 결과 순서대로 employees 테이블을 한번 더 읽어서 last_name을 가져오고, 최종적으로 그 결과를 클라이언트 쪽으로 반환합니다.

`MySQL 예전 정렬 방식인 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 비효율적이라 할 수 있는데, 새로운 정렬 방식인 싱글 패스는 테이블을 한번만 읽기 때문에 효율적이라 할 수 있습니다.` ⭐⭐

하지만! 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요합니다. 즉, 소트 버퍼 공간의 크기와 레코드 크기에 의존적이게 됩니다. ⭐⭐

최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주료 사용하지만, 최신 버전의 MySQL 서버라고 해서 항상 싱글 패스 정렬 방식을 사용하는 것은 아닙니다.

- 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될 때

싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라 할 수 있습니다. ⭐⭐

> SELECT 쿼리에서 꼭 필요한 컬럼만 조회하지 않고, 모든 컬럼(*)을 가져오도록 개발할 때가 많다. 하지만 이는 정렬 버퍼를 몇 배에서 몇십 배 까지 비효율적으로 사용할 가능성이 크다. SELECT 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하는 것이 좋다고 권장하는 것은 바로 위와 같은 이유 때문이다. 특히 정렬이 필요한 SELECT는 불필요한 컬럼을 SELECT 하지 않게 쿼리를 작성하는 것이 효율적이다. 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 쿼리에서도 영향을 미친다. ⭐⭐⭐ 

<br>

## `정렬 처리 방법`

| 정렬 처리 방법                    | 실행 계획의 Extra 컬럼 내용                         |
|-----------------------------|--------------------------------------------|
| 인덱스를 사용한 정렬                 | 별도 표기 없음                                   |
| 조인에서 드라이빙 테이블만 정렬           | "Using filesort" 메세지가 표시됨                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "Using temporary; Using filesort" 메세지가 표시됨 |

쿼리에 ORDER BY가 사용되면 반드시 3가지 처리 방법 중 하나로 정렬이 처리됩니다. 일반적으로 아래쪽에 있는 정렬 방법으로 갈수록 처리 속도는 떨어집니다.

<br>

### `인덱스를 이용한 정렬`

- ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 함
- WHERE 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. 

인덱스를 이용한 정렬을 위해서는 반드시 위의 2가지 조건이 필요합니다. 

```sql
mysql> SELECT *
       FROM employees e, salaries s
       WHERE s.emp_mo=e.emp_no
       AND e.emp_no BETWEEN 100002 AND 100020
       ORDER BY e.emp_no;
```

```sql
// emp_no 컬럼으로 정렬이 필요한데, 인덱스를 사용하면서 자동으로 정렬이 된다고 ORDER BY 절을 제거하는 것은 좋지 않은 선택이다.
mysql> SELECT *
       FROM employees e, salaries s
       WHERE s.emp_mo=e.emp_no
       AND e.emp_no BETWEEN 100002 AND 100020
```

인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 됩니다. (B-Tree 인덱스가 키 값으로 정렬되어 있기 때문에 가능하다.)

> ORDER BY 절을 포함하면 MySQL 서버가 별도로 정렬 작업을 한 번 더 할까봐 걱정스러워서 안넣는 경우가 있는데, MySQL 서버는 정렬을 인덱스로 처리할 수 있는 경우 부가적으로 불필요한 정렬 작업을 수행하지 않는다.

<br>

### `조인의 드라이빙 테이블만 정렬`

```sql
mysql> SELECT *
       FROM employees e, salaries s
       WHERE s.emp_no=e.emp_no
        AND e.emp_no BETWEEN 100002 AND 100010
       ORDER BY e.last_name;
```

조인이 수행되면 결과 레코드의 건수가 몇 배로 들어나기 때문에 `조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬에 효율적일 것입니다.`

이러한 방법이 수행되려면 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 컬럼만으로 ORDER BY 절을 작성해야 합니다.

ORDER BY에 존재하는 컬럼은 드라이빙 테이블의 컬럼이긴 한데 인덱스가 존재하는 컬럼이 아니기 때문에 `인덱스를 이용해서 정렬하는 것은 불가능합니다.`

<img width="1118" alt="스크린샷 2024-08-04 오후 9 52 07" src="https://github.com/user-attachments/assets/ba18af87-afa5-4163-b54a-589284ee89df">

1. 인덱스를 이용해 `e.emp_no BETWEEN 100002 AND 100010 조건을 만족하는 9건을 검색`
2. 검색 결과를 last_name 컬럼으로 정렬을 수행(Filesort)
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 최종 결과를 가져옴

<br>

### `임시 테이블을 이용한 정렬`

```sql
mysql> SELECT *
       FROM employees e, salaries s
       WHERE s.emp_no=e.emp_no
        AND e.emp_no BETWEEN 100002 AND 100010
       ORDER BY s.salary;
```

임시 테이블을 이용한 정렬이 3가지 방법 중에 가장 느린 방법입니다. 이번 쿼리에서는 ORDER BY 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블(salaries)에 있는 컬럼입니다.

`즉, 정렬이 수행되기 전에 salaries 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬할 수 밖에 없습니다.` ⭐⭐

쿼리의 실행 계획을 보면 Extra 컬럼에 `"Using temporary; Using filesort" 라는 커멘트가 표시됩니다.` 이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미합니다.

<img width="902" alt="스크린샷 2024-08-04 오후 10 18 26" src="https://github.com/user-attachments/assets/8fb4d794-9588-4d31-903b-06b06cd30784">

<br>

### `정렬 처리 방법의 성능 비교`

- ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수 만큼만 가져와서는 처리할 수 없다.
- 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그룹 작업을 실행해야만 비로소 LIMIT 으로 건수를 제한할 수 있다.
- WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다.

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그룹 작업이 왜 느리게 작동할 수 밖에 없는지 알아보겠습니다.

<br>

#### `스트리밍 방식`

<img width="507" alt="스크린샷 2024-04-12 오후 11 57 14" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/6ed52f6f-5d3c-4ad1-874e-464b65c78071">

`서버 쪽에서 처리할 데이터가 얼마인지에 관계 없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 것을 의미합니다.`

스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하냐에 상관없이 빠른 응답 속도를 보장해줍니다. 

대표적으로 스트리밍 방식은 인덱스를 사용한 정렬 방식인데, 여기에 LIMIT 쿼리까지 같이 사용한다면 제한된 건수만큼만 읽으면서 바로바로 클라이언트로 결과를 전송해줄 수 있습니다.

<br>

#### `버퍼링 방식`

<img width="603" alt="스크린샷 2024-04-13 오전 12 01 22" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/828add8b-50a7-4c58-8310-616595e01205">

ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 합니다. WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그룹핑해서 차례대로 보내야 하기 때문입니다.

MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무 것도 하지 않고 기다려야 하기 때문에 응답 속도는 느려집니다.

- 인덱스를 사용한 정렬
- 조인에서 드라이빙 테이블만 정렬 (`Using filesort`)
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 (`Using temporary; Using filesort`)

ORDER BY의 3가지 처리 방법 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후의 정렬됩니다.

위에서 설명한 스트리밍 방식의 예시인 `인덱스를 사용한 정렬 방식은 LIMIT으로 제한된 건수만큼만 읽으면서 바로바로 클라이언트로 결과를 전송해줄 수 있습니다.` ⭐⭐ 

`하지만 인덱스를 사용하지 못하는 경우의 처리는 필요한 모든 레코드를 디스크로부터 읽어서 정렬한 후에야 비로소 LIMIT 으로 제한된 건수만큼 잘라서 클라이언트로 전송해줄 수 있음을 의미합니다. 이러한 이유 떄문에 ORDER BY, GROUP BY가 인덱스를 활용하지 못했을 때 느린 것입니다.` ⭐⭐

<br>

#### `정렬 쿼리 예시`

```sql
mysql> SELECT *
       FROM tb_test1 t1, tb_test2 t2
       WHERE t1.col1=t2.col1
       ORDER BY t1.col2
       LIMIT 10;
```

- `tb_test1`: 레코드 100건
- `tb_test2`: 레코드 1,000건 (tb_test1의 레코드 1건당 tb_test2의 레코드가 10건씩 존재한다 가정)
- 두 테이블의 조인 결과 전체 1,000건

<br>

| 정렬 방법            | 읽어야 할 건수                          | 조인 횟수                               | 정렬해야 할 대상 건수                        | 상황                                                        |
|------------------|-----------------------------------|-------------------------------------|-------------------------------------|-----------------------------------------------------------|
| 인덱스 사용           | tb_test1: 1건 <br> tb_test2: 10건   | 1번                                  | 0건                                  | ORDER BY col2 인덱스 컬럼일 때                                   |
| 조인의 드라이빙 테이블만 정렬 | tb_test1: 100건 <br> tb_test2: 10건 | 1번                                  | 100건 (tb_test1 테이블의 레코드 건수만큼 정렬 필요) | ORDER BY col2 인덱스 컬럼이 아닐 때                                |         |
| 임시 테이블 사용 후 정렬   | tb_test1: 100건, tb_test2: 1000건   | 100번 (tb_test1 테이블의 레코드 건수만큼 조인 발생) | 1,000건 (조인된 결과 레코드 건수를 전부 정렬해야 함)   | ORDER BY col2 드라이빙 테이블(tb_test1)이 아닌 드리븐 (tb_test2) 컬럼일 때 |

- tb_test1이 드라이빙 되는 경우

<br>

| 정렬 방법            | 읽어야 할 건수                          | 조인 횟수                                 | 정렬해야 할 대상 건수                        | 상황                                                        |
|------------------|-----------------------------------|---------------------------------------|-------------------------------------|-----------------------------------------------------------|
| 인덱스 사용           | tb_test1: 10건 <br> tb_test2: 10건  | 10번                                   | 0건                                  | ORDER BY col2 인덱스 컬럼일 때                                   |
| 조인의 드라이빙 테이블만 정렬 | tb_test1: 100건 <br> tb_test2: 10건 | 10번                                   | 100건 (tb_test2 테이블의 레코드 건수만큼 정렬 필요) | ORDER BY col2 인덱스 컬럼이 아닐 때                                |         |
| 임시 테이블 사용 후 정렬   | tb_test1: 1000건, tb_test2: 100건   | 1,000번 (tb_test2 테이블의 레코드 건수만큼 조인 발생) | 1,000건 (조인된 결과 레코드 건수를 전부 정렬해야 함)   | ORDER BY col2 드라이빙 테이블(tb_test2)이 아닌 드리븐 (tb_test1) 컬럼일 때 |

- tb_test2이 드라이빙 되는 경우

어느 테이블이 드라이빙 되어 조인 되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만듭니다. 가능하다면 인덱스를 사용하여 정렬하도록 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법입니다.

<br>

## `GROUP BY 처리`



<br>

## `DISTINCT 처리`

<br>

## `고급 최적화`

### `인덱스 컨디션 푸시다운(index_condition_pushdown)`

MySQL 5.6 버전부터는 인덱스 컨디션 푸시다운(`Index Condition Pushdown`) 이라는 기능이 도입 되었는데요. 어떤 내용인지 알아보겠습니다.

- secondary index에만 사용됩니다.
- 전체 row 읽기의 수를 줄여 I/O 작업을 줄이는 것.
- 인덱스를 범위 제한 조건으로 사용하지 못하는 쿼리에 한해서 발생하는 것 같음 (`LIKE %name%`, `like > 10` 같이 인덱스를 이용하지 못하는 범위 검색을 의미하는 것 같음)
- InnoDB Clustered index의 경우, 전체 레코드가 InnoDB 버퍼에 존재하기 때문에, 인덱스 컨디션 푸시다운을 사용해도 I/O가 감소하지 않음

<br>

#### `MySQL SQL 수행 절차`

<img width="780" alt="스크린샷 2024-04-10 오전 12 51 30" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/bd4a6fce-87d2-4e4d-93c5-6fed1c1749b8">

- `MySQL 엔진`: 스토리지 엔진에서 받은 데이터 가공 처리 역할 (쿼리의 최적화된 실행을 위한 옵티마이저가 중심)
- `스토리지 엔진`: 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 담당 (대표적으로 인덱스를 비교하는 담당)

<br>

#### `인덱스 푸시다운 예제`

```
+----+-------------+-------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-------------------------+
| id | select_type | table | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered |          Extra          |
+----+-------------+-------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-------------------------+
|  1 | SIMPLE      | c     | NULL       | index | idx_last_name_address | idx_last_name_address |  10     | NULL |   10 |   100.00 |  Using index condition  |
+----+-------------+-------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-------------------------+
```

인덱스 푸시다운은 쿼리의 실행 계획 extra 컬럼에서 `Using index condition`로 표시되는데요. 어떤 상황에서 발생하는지 확인 해보겠습니다.

```sql
SET optimizer_switch='index_condition_pushdown=on';
ALTER TABLE people ADD INDEX idx_last_name_address (zipcode, lastname, address)
```

```sql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%sal'
  AND address LIKE '%Main Street%';
```

만약에 인덱스 컨디션 푸시다운이 없을 때 위의 쿼리가 실행된다면 어떻게 실행 될까요?

1. `zipcode=95054`에 해당하는 값들을 스토리지 엔진을 통해서 읽어옴 (`idx_last_name_address` 인덱스를 통해서 데이터 파일에 접근하여 데이터를 읽어옴)
2. `lastname LIKE '%sal'`에 해당하는 조건을 MySQL 엔진에서 필터링 함
    - last_name이 `Marsja`, `Masaki` 같이 굳이 테이블을 읽지 않아도 되는 데이터도 데이터 파일에 접근하여 불필요한 Disk I/O 발생
    - `만약에 10만건 읽고 필터링 되어서 1건 남았다면 99,999건의 불필요한 Disk I/O 발생`

<img width="975" alt="스크린샷 2024-04-10 오전 1 04 28" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/5e857cd2-01eb-4381-804d-418593faeb50">

여기서 2번 과정을 보면 비효율적이라는게 보이는데요.

비효율적인 이유가 무엇이냐면 이미 1번 과정(`zipcode=95054`)에서 인덱스 파일을 읽어서 데이터 파일에 접근하여 데이터를 가져온 것을 볼 수 있습니다. (스토리지 엔진에서 인덱스 사용하여 디스크 파일에 접근하여 데이터를 MySQL 엔진으로 반환했음)

MySQL 엔진에서는 굳이 3건 모두 디스크 파일에 접근하지 않더라도 스토리지 엔진에서 반환한 값을 보면 `lastname LIKE '%sal'` 해당하는 결과가 1건이라는 것을 알 수 있습니다.

즉, 1건만 디스크에 접근해서 가져오면 되고 굳이 필터링 되어 버려진 값들에 대해서 모두 불필요하게 Disk 접근을 할 필요가 없다는 뜻입니다.

`하지만 MySQL 5.5 버전까지는 인덱스를 범위 제한 조건으로 사용하지 못하는 lastname 조건은 MySQL 엔진이 스토리지 엔진으로 아예 전달하지 못한다고 합니다.`

```
MySQL 엔진 (핸들러 API 사용)-> 스토리지 엔진 -> 디스크 파일
```

정리하면 MySQL 엔진에서 lastname 조건 처럼 인덱스를 사용하지 못하는 범위 검색의 경우 핸들러 API에서 스토리지 엔진으로 넘겨주지 않기 때문에 스토리지 엔진의 입장에서는 모두 디스크 파일에 접근하여 I/O를 발생시킬 수 밖에 없었던 것입니다.

<br>

<img width="1066" alt="스크린샷 2024-04-10 오전 1 18 44" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/1e2b2dc3-f763-4f0a-bd69-01eb9b50ea37">

그래서 MySQL 5.6 버전부터는 인덱스를 사용하지 못하는 범위 검색이라 하더라도 모두 같이 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선되어, 위처럼 스토리지 엔진에서 MySQL 엔진으로 부터 받은 필터링 조건으로 불필요한 Disk I/O를 줄이는 것을 볼 수 있습니다.

> 핸들러 API: MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청 API

<br>

#### `인덱스 컨디션 푸시 다운 on/off`

```sql
SET optimizer_switch='index_condition_pushdown=off';
SET optimizer_switch='index_condition_pushdown=on';
```

위의 명령어로 인덱스 푸시 다운 설정을 on/off 할 수 있습니다.

<br>

## `쿼리 힌트`

MySQL 버전이 업그레이드되고 통계 정보나 옵티마이저 최적화 방법들이 더 다양해지면서 쿼리의 실행 계획 최적화가 많이 좋아지고 있습니다. 하지만 개발자가 원하는 대로 최적화가 동작하지 않을 때가 있습니다.

이런 경우에는 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할지 알려줄 수 있는 방법이 필요한데, 이 때 `MySQL 옵티마이저 힌트`를 사용할 수 있습니다.

- 인덱스 힌트
- 옵티마이저 힌트

두 가지가 존재하는데 하나씩 알아보겠습니다.

<br>

### `인덱스 힌트`

`인덱스 힌트는 SELECT, UPDATE 쿼리에서만 사용할 수 있습니다.`

<br>

## `Reference`

- [Real MySQL - 1]()
- [https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size)
- [https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html](https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html)
- [https://jojoldu.tistory.com/474](https://jojoldu.tistory.com/474)