## `MySQL 트랜잭션과 잠금`

`트랜잭션`은 작업의 완전성을 보장해 주는 것입니다. 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partition Update)이 발생하지 않게 만들어주는 기능입니다.

<br>

## `MySQL 엔진의 잠금`

MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있습니다. 

<br>

## `InnoDB 스토리지 엔진 잠금`

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있습니다.

<img width="484" alt="스크린샷 2024-03-10 오후 8 08 46" src="https://media.oss.navercorp.com/user/30855/files/75f45542-ecc0-4754-8c5a-17916e390809">

<br>

### `InnoDB 스토리지 엔진의 잠금`

<br>

### `레코드 락`

레코드 자체만을 잠그는 것을 `레코드 락(Record lock)` 이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 합니다. 한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점입니다.

<br>

### `갭 락`

갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미합니다. 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT) 되는 것을 제어하는 것입니다.

갭 락은 그 자체로 쓰이는 것보다 넥스트 키 락의 일부로 자주 사용됩니다.

<br>

### `넥스트 키 락`

`레코드 락`과 `갭 락`을 합쳐 놓은 형태의 잠금을 `넥스트 키 락` 이라고 합니다.

InnoDB의 갭 락과 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적입니다.

<br>

### `자동 증가 락`

MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT 라는 컬럼 속성을 제공합니다. AUTO INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 합니다. InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 `AUTO_INCREMENT 락` 이라고 하는 테이블 수준의 잠금을 사용합니다.

AUTO_INCREMENT 락은 INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않습니다.

자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위해서입니다. INSERT 쿼리가 실패했더라도 한 번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남습니다.

<br>

## `인덱스와 잠금`

InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있습니다. `레코드 락`에서 InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다고 하였습니다.

즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 합니다.

```sql
mysql> SELECT COUNT(*) FROM employees WHERE first_name = 'Gyunny';
```

- 253건

<br>

```sql
mysql> SELECT COUNT(*) FROM employees WHERE first_name = 'Gyunny' AND last_name = 'Choi';
```

- 1건

<br>

```sql
mysql> UPDATE employees SET hire_date=NOW() WHERE first_name='Gyunny' AND last_name = 'Choi';
```

여기서 `first_name` 에만 인덱스가 존재할 때 UPDATE 쿼리가 실행된다면 검색해야 할 레코드인 253건이 모두 잠기게 됩니다.

이 테이블에 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 UPDATE 작업을 하는데, 이 과정에서 테이블에 있는 모든 레코드를 잠그게 됩니다. 즉, MySQL InnoDB에서 인덱스 설계가 중요한 이유 입니다.

<br>

## `MySQL 격리 수준`

