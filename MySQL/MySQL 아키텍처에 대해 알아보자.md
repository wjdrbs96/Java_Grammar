## `MySQL 아키텍처에 대해 알아보자`

<img width="523" alt="스크린샷 2024-02-25 오후 11 09 06" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/88ad522c-f680-4279-aa90-887c55bde3c1">

이번 글에서는 MySQL 아키텍쳐에 대해서 알아보겠습니다.

<br>

### `MySQL 엔진`

MySQL 엔진은 클라이언트로부터의 접속, 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룹니다.

<br>

### `스토리지 엔진`

MySQL 엔진은 `DBMS의 두뇌에 해당하는 처리 수행을 하고`, `실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담`합니다.

<br>

### `핸들러 API`

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 핸들러 요청이라 하며 여기서 사용되는 API를 `핸들러 API` 라고 합니다.

<br>

## `InnoDB 스토리지 엔진 아키텍쳐`

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어납니다.

<br>

### `프라이머리 키에 의한 클러스터링`

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장됩니다.

<br>

### `외래키 지원`

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋습니다.

<br>

### `MVCC(Multi Version Concurrecy Control)`

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있습니다.

멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 것을 의미합니다. 

`READ_COMMITTED`인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 알아보겠습니다.

<img width="737" alt="스크린샷 2024-03-01 오후 8 53 09" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/db1426ad-cbad-4ec2-b1d8-3ffc2c78d812">

```sql
mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, 'Gyunny', '서울');
```

멤버 하나를 저장 했다면 MySQL 상태는 위처럼 될 것입니다. 

<br>

```sql
mysql> UPDATE member SET m_area = '경기' WHERE m_id = 12;
```

만약 위처럼 특정 컬럼을 변경했다면 MySQL InnoDB 에서는 어떤 일이 발생할까요?

<br>

<img width="669" alt="스크린샷 2024-03-01 오후 9 00 41" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/0598a77f-ff96-4b89-956f-0a3019d49d19">

위처럼 `InnoDB 버퍼풀에 변경된 내용이 쓰여지고, 백그라운드 쓰레드에 의해 데이터 파일에 변경된 내용을 반영하게 됩니다.` 그리고 `변경 전의 내용을 언두 로그에 저장해둡니다.`

그렇다면 `COMMIT, ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회할까?`

```sql
mysql> SELECT * FROM member WHERE m_id = 12;
```

답은 `트랜잭션 격리 수준`을 어떤 것을 사용하고 있냐에 따라 다릅니다. 

- `READ_UNCOMMITTED`: InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환합니다. 즉, 데이터가 커밋됐든 아니든 변경된 상태의 데이터를 반환합니다.
- `READ_COMMITTED, REPEATABLE READ, SERIALIZABLE`: 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환합니다.

이러한 과정을 DBMS 에서는 `MVCC` 라고 합니다. 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조입니다.

이 상태에서 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버립니다. 하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해버립니다.

<br>

### `잠금 없는 일관된 읽기(Non-Locking Consitent Read)`

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행합니다. 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능합니다.

격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준의 경우 INSERT와 연결되지 않은 단순 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됩니다.

특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않습니다. 이를 `잠금 없는 일관된 읽기` 라고 합니다.

<br>

<img width="526" alt="스크린샷 2024-03-01 오후 9 50 08" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/20bc31c9-5427-45b8-a814-b686356bdce7">

<br>

## `InnoDB 버퍼 풀`

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간입니다. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이합니다.

일반적으로 INSERT, UPDATE, DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킵니다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있습니다.

<br>

### `버퍼 풀의 구조`

InnoDB 스토리지 엔진은 버퍼 풀이라는 메모리 공간을 페이지 크기로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 저장합니다.

버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 `LRU(Least Recently Used)`, `플러시(Flush) 리스트`, `프리(Free) 리스트` 라는 3개의 자료 구조를 관리합니다.

<img width="464" alt="스크린샷 2024-03-03 오후 7 14 12" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/6e5edad2-932d-421c-a47a-071b3edf451d">

LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀이 메모리에 유지해서 디스크 읽기를 최소화하는 것입니다.

플러시 리스트는 `디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(= 더티 페이지)`의 리변경 시점 기준의 페이지 목록을 관리합니다. 

한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록되어야 합니다. `데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영합니다.`

그래서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결됩니다.

<br>

### `버퍼 풀과 리두 로그`

InnoDB 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있습니다. InnoDB 버퍼 풀은 DB 성능 향상을 위해 `데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있습니다.`

<img width="688" alt="스크린샷 2024-03-03 오후 7 49 21" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/7cc9b51d-67ab-4195-9164-351c78cb8739">

InnoDB 버퍼 풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 `클린 페이지(Clean Page)`와 함께 INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 `더티 페이지(Dirty Page)`도 가지고 있습니다. 

내부적으로 엄청 복잡한 과정이 있지만, 간단하게 말하면 InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화 시키는 작업을 진행합니다.

<br>

## `Double Write Buffer`

InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록합니다. 이렇게 일부만 기록하게 되면 InnoDB 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 해당 내용을 복구할 수 없습니다. 

InnDB 스토리지 엔진에서는 이 같은 문제를 막기 위해 `Double Write 기법`을 이용합니다.

<img width="943" alt="스크린샷 2024-03-03 오후 8 17 57" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/e8c488e8-a5b3-4f6d-bf88-d63d4dc4dfad">

InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 `DoubleWrite 버퍼에 기록` 합니다.

`DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용됩니다.` 만약에 시스템이 비정상으로 종료되어 복구가 필요하게 되었다면, DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사합니다.

<br>

## `언두 로그`

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 INSERT, UPDATE, DELETE로 변경되기 이전 버전의 데이터를 별도로 백업합니다. 

- `트랜잭션 보장`: 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이 때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구합니다.
- `격리 수준 보장`: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 합니다.

<br>

## `체인지 버퍼`

RDBMS 에서 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함딘 인덱스를 업데이트하는 작업도 필요합니다.

인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 됩니다.

그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이 때 사용하는 임시 메모리 공간을 `체인지 버퍼(Change Buffer)` 라고 합니다.

<br>

## `어댑티브 해시 인덱스`

`어댑티브 해시 인덱스`는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스입니다.

DB 서바가 얼마나 많은 일을 하냐에 따라 B-Tree 인덱스에서 값을 찾는 과정이 느려질 수도 있고 빨라질 수도 있습니다.

어댑티브 해시 인덱스는 이러한 B-Tree 검색 시간을 줄여주기 위해 도입된 기능입니다. InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있습니다.

<br>

## `Referenece`

- Real MySQL - 1