## `MySQL 아키텍처에 대해 알아보자`

<img width="523" alt="스크린샷 2024-02-25 오후 11 09 06" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/88ad522c-f680-4279-aa90-887c55bde3c1">

이번 글에서는 MySQL 아키텍쳐에 대해서 알아보겠습니다.

<br>

### `MySQL 엔진`

MySQL 엔진은 클라이언트로부터의 접속, 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룹니다.

<br>

### `스토리지 엔진`

MySQL 엔진은 `DBMS의 두뇌에 해당하는 처리 수행을 하고`, `실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담`합니다.

<br>

### `핸들러 API`

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 핸들러 요청이라 하며 여기서 사용되는 API를 `핸들러 API` 라고 합니다.

<br>

## `InnoDB 스토리지 엔진 아키텍쳐`

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어납니다.

<br>

### `프라이머리 키에 의한 클러스터링`

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장됩니다.

<br>

### `외래키 지원`

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋습니다.

<br>

### `MVCC(Multi Version Concurrecy Control)`

읿란적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있습니다.

멀티 버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 것을 의미합니다. 

`READ_COMMITTED`인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경을 어떻게 처리하는지 알아보겠습니다.

<img width="737" alt="스크린샷 2024-03-01 오후 8 53 09" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/db1426ad-cbad-4ec2-b1d8-3ffc2c78d812">

```sql
mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, 'Gyunny', '서울');
```

멤버 하나를 저장 했다면 MySQL 상태는 위처럼 될 것입니다. 

<br>

```sql
mysql> UPDATE member SET m_area = '경기' WHERE m_id = 12;
```

만약 위처럼 특정 컬럼을 변경했다면 MySQL InnoDB 에서는 어떤 일이 발생할까요?

<br>

<img width="669" alt="스크린샷 2024-03-01 오후 9 00 41" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/0598a77f-ff96-4b89-956f-0a3019d49d19">

위처럼 `InnoDB 버퍼풀에 변경된 내용이 쓰여지고, 백그라운드 쓰레드에 의해 데이터 파일에 변경된 내용을 반영하게 됩니다.` 그리고 `변경 전의 내용을 언두 로그에 저장해둡니다.`

그렇다면 `COMMIT, ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회할까?`

```sql
mysql> SELECT * FROM member WHERE m_id = 12;
```

답은 `트랜잭션 격리 수준`을 어떤 것을 사용하고 있냐에 따라 다릅니다. 

- `READ_UNCOMMITTED`: InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환합니다. 즉, 데이터가 커밋됐든 아니든 변경된 상태의 데이터를 반환합니다.
- `READ_COMMITTED, REPEATABLE READ, SERIALIZABLE`: 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환합니다.

이러한 과정을 DBMS 에서는 `MVCC` 라고 합니다. 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조입니다.

이 상태에서 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버립니다. 하지만 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해버립니다.

<br>

### `잠금 없는 일관된 읽기(Non-Locking Consitent Read)`

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행합니다. 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능합니다.

격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준의 경우 INSERT와 연결되지 않은 단순 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됩니다.

특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않습니다. 이를 `잠금 없는 일관된 읽기` 라고 합니다.

<br>

<img width="526" alt="스크린샷 2024-03-01 오후 9 50 08" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/20bc31c9-5427-45b8-a814-b686356bdce7">

<br>

### `InnoDB 버퍼 풀`

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간입니다. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이합니다.

일반적으로 INSERT, UPDATE, DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킵니다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있습니다.

<br>

### `버퍼 풀의 구조`

InnoDB 스토리지 엔진은 버퍼 풀이라는 메모리 공간을 페이지 크기로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 저장합니다.

버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 `LRU(Least Recently Used)`, `플러시(Flush) 리스트`, `프리(Free) 리스트` 라는 3개의 자료 구조를 관리합니다.

<img width="464" alt="스크린샷 2024-03-03 오후 7 14 12" src="https://github.com/wjdrbs96/Today-I-Learn/assets/45676906/6e5edad2-932d-421c-a47a-071b3edf451d">

LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀이 메모리에 유지해서 디스크 읽기를 최소화하는 것입니다.

플러시 리스트는 `디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(= 더티 페이지)`의 리변경 시점 기준의 페이지 목록을 관리합니다. 

한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록되어야 합니다. `데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영합니다.`

그래서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결됩니다.

<br>

### `버퍼 풀과 리두 로그`

InnoDB 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있습니다.  

<br>

